# 探索接口（/dungeons/runs/{runId}/explore）实现说明

## 📋 接口功能概述

**探索接口**是地牢探索系统的核心，负责处理玩家在地图上的移动、触发事件、遭遇敌人等操作。它支持两种探索模式：
1. **地图模式**：玩家可以选择房间移动（基于地图配置）
2. **线性模式**：按顺序自动探索（兼容旧逻辑）

---

## 🔄 整体工作流程

### 第一步：前置检查
```
1. 验证 run 是否存在且属于当前用户
2. 检查探索状态：
   - 如果已 completed，抛出异常（不能再探索）
   - 如果 awaitingBattle，抛出异常（必须先处理战斗）
3. 获取关卡信息（stage）和当前进度状态（RunProgressState）
```

### 第二步：解析请求参数
```java
action: "explore" | "move" | "event"  // 默认 "explore"
targetRoomId: Integer  // 目标房间ID（地图模式需要）
```

### 第三步：解析地图配置
```java
// 从 stage.explorationMap（JSON字符串）解析出：
rooms: [{id, type, name, x, y, description}, ...]  // 房间列表
paths: [[fromRoomId, toRoomId], ...]  // 路径连接关系
```

---

## 🗺️ 两种探索模式详解

### 模式A：地图模式（推荐使用）

**触发条件**：`targetRoomId != null && action == "move"`

#### 工作流程：

```
1. 获取当前房间ID
   ├─ 如果 state.currentRoomId 为空 → 查找起始房间（type="start"）
   └─ 设置当前房间ID

2. 验证路径是否可达
   └─ 使用 BFS 算法检查从当前房间到目标房间是否存在路径
      ├─ 如果不可达 → 抛出异常
      └─ 如果可达 → 继续

3. 执行移动
   ├─ 更新 currentRoomId = targetRoomId
   ├─ exploredRooms += 1
   └─ 添加到 visitedRooms（如果未访问过）

4. 根据目标房间类型触发内容
   ├─ type="start" → 仅提示到达入口
   ├─ type="end" → 标记探索完成（status="completed"）
   ├─ type="boss" → 必定触发Boss战斗（prepareBattle）
   ├─ type="event" → 必定触发随机事件（添加到eventLog）
   └─ type="normal" → 随机触发（50%事件 / 50%敌人）
```

#### 示例请求：
```json
POST /dungeons/runs/123/explore
{
  "action": "move",
  "targetRoomId": 5
}
```

---

### 模式B：线性模式（兼容旧逻辑）

**触发条件**：`targetRoomId == null` 或 `action != "move"`

#### 工作流程：

```
1. 自动递增探索房间数
   └─ exploredRooms += 1
   └─ currentRoom = "Room-" + exploredRooms

2. 根据 action 决定触发内容
   ├─ action="event" → 强制触发随机事件
   └─ action="explore" → 随机决定（50%事件 / 50%敌人）
```

#### 示例请求：
```json
POST /dungeons/runs/123/explore
{
  "action": "explore"
}
// 或直接 POST 不传 body（默认 action="explore"）
```

---

## 🎲 房间类型与触发逻辑

### 房间类型（type）：
- **start**：起始房间，仅记录到达
- **end**：终点房间，标记探索完成
- **boss**：Boss房间，**必定触发Boss战斗**
- **event**：事件房间，**必定触发随机事件**
- **normal**：普通房间，**随机触发事件或敌人**（各50%概率）

### 触发内容类型：

#### 1. 触发事件
```java
Event event = eventService.triggerRandomDungeonEvent(stageNumber, chapterNumber);
// 将事件摘要添加到 eventLog
state.getEventLog().add(buildEventSummary(event));
// 返回事件信息给前端
```

#### 2. 遭遇敌人
```java
Enemy enemy = selectStageEnemy(stage);
// 准备战斗（标记状态，保存敌人信息）
state.prepareBattle(enemy, enemyService.getEnemyCardsByEnemyId(enemy.getId()));
// 返回战斗待处理标记（battlePending=true）
```

---

## 📦 关键数据结构

### RunProgressState（存储在 runs.current_stage_progress）
```java
{
  status: "exploring" | "awaiting_battle" | "completed" | "abandoned",
  currentRoom: "房间名称",
  currentRoomId: 房间ID（地图模式）,
  visitedRooms: [已访问的房间ID列表],
  exploredRooms: 已探索房间数量,
  defeatedEnemies: 已击败敌人数量,
  eventLog: ["事件摘要1", "事件摘要2", ...],
  battleLog: ["战斗日志1", "战斗日志2", ...],
  awaitingBattle: true/false,
  pendingEnemyId: 待处理敌人ID,
  pendingEnemyName: 待处理敌人名称,
  pendingEnemyDifficulty: 敌人难度,
  pendingEnemyCards: [敌人卡牌列表]
}
```

### RunActionResponse（接口返回）
```java
{
  run: RunDTO,  // 更新后的探索记录
  message: "操作结果消息",
  eventSummary: "事件摘要（如果有）",
  battlePending: true/false,  // 是否有待处理战斗
  pendingEnemyId: 敌人ID,
  pendingEnemyName: 敌人名称,
  pendingEnemyDifficulty: 敌人难度,
  pendingEnemyCards: [敌人卡牌列表]
}
```

---

## 🎯 完整探索流程示例

### 场景：玩家在地图上从房间1移动到房间5

```
1. 前端调用：POST /dungeons/runs/123/explore
   {
     "action": "move",
     "targetRoomId": 5
   }

2. 后端处理：
   ├─ 检查当前房间ID = 1（已记录）
   ├─ 验证路径：1 → 2 → 5 是否可达（BFS检查）✅
   ├─ 移动：currentRoomId = 5，exploredRooms += 1
   ├─ 查找房间5信息：type="normal"
   └─ 随机触发：50%概率 → 触发敌人

3. 如果触发敌人：
   ├─ prepareBattle() 标记 awaitingBattle=true
   ├─ 保存敌人信息到 pendingEnemy*
   └─ 返回 battlePending=true

4. 前端收到响应：
   ├─ battlePending=true → 跳转到战斗界面
   ├─ 显示 pendingEnemyName="暗黑骷髅"
   └─ 战斗结束后调用 /battle 接口结算

5. 战斗结算后：
   ├─ awaitingBattle=false
   └─ 可以继续调用 /explore 探索下一个房间
```

---

## 🔧 核心辅助方法

### 1. `isPathReachable()` - 路径可达性检查
- **算法**：BFS（广度优先搜索）
- **逻辑**：构建双向邻接表，从起点BFS搜索到终点
- **返回**：true=可达，false=不可达

### 2. `findStartRoom()` - 查找起始房间
- **逻辑**：遍历rooms列表，找到type="start"的房间
- **返回**：起始房间ID，如果没找到返回第一个房间ID

### 3. `prepareBattle()` - 准备战斗
- **功能**：标记状态为awaiting_battle，保存敌人信息
- **影响**：后续必须调用/battle接口才能继续探索

### 4. `parseMapConfig()` - 解析地图JSON
- **输入**：explorationMap JSON字符串
- **输出**：包含rooms和paths的Map结构

---

## ⚠️ 重要约束

1. **必须先处理战斗**：如果`awaitingBattle=true`，必须调用`/battle`接口结算后才能继续探索
2. **路径验证**：地图模式下，只能移动到**有路径连接**的房间
3. **探索完成**：到达`type="end"`的房间后，状态变为`completed`，不能再探索
4. **数据持久化**：每次探索操作后，`RunProgressState`会序列化为JSON并保存到`runs.current_stage_progress`

---

## 💡 使用建议

1. **推荐使用地图模式**：提供更好的游戏体验，玩家可以选择探索路径
2. **前端实现**：
   - 调用`GET /dungeons/stages/{stageNumber}/map`获取地图配置
   - 显示可移动的房间（根据paths计算可达房间）
   - 玩家点击房间后调用`/explore`接口
   - 根据`battlePending`判断是否需要跳转战斗界面
3. **错误处理**：
   - 如果返回"无法到达目标房间" → 前端禁用该房间按钮
   - 如果返回"仍有未处理的战斗" → 提示玩家先完成战斗

---

## 📝 总结

探索接口是一个**状态机**，负责：
- ✅ 管理玩家在地图上的位置和探索进度
- ✅ 根据房间类型智能触发事件或战斗
- ✅ 维护探索历史（eventLog、battleLog）
- ✅ 控制游戏流程（必须处理战斗后才能继续）

通过这个接口，玩家可以自由探索地牢，触发各种事件和战斗，直到到达终点完成探索。

